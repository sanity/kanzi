package msmd;
import java.util.*;
import java.io.*;
import org.w3c.dom.*;
import org.w3c.dom.Node;
import javax.xml.parsers.*;

/**
 *  Description of the Class
 *
 * @author     ian
 * @created    September 18, 2002
 */
public class Matcher {

    /**  Description of the Field */
    public final static boolean DEBUG = false;

    /**  Description of the Field */
    public float nodeSiblingPosWeight = 0.2F;
    /**  Description of the Field */
    public float nodeNameWeight = 0.2F;
    /**  Description of the Field */
    public float nodeValueWeight = 0.2F;
    /**  Description of the Field */
    public float attributeNumberWeight = 0.2F;
    /**  Description of the Field */
    public float childNumberWeight = 0.2F;

    /**  Description of the Field */
    public float childrenWeight = 0.2F;
    /**  Description of the Field */
    public float attributeWeight = 0.1F;
    /**  Description of the Field */
    public float parentWeight = 0.5F;
    /**  Description of the Field */
    public float localWeight = 0.2F;

    /**  Description of the Field */
    public Hashtable cache;


    /**
     * Construct a new matcher object, oldDoc is the original document
     * from which fragments are taken
     */
    public Matcher() { }


    /**
     *  Identify candidate positions for a fragment in this new document
     *
     * @param  newDoc    The new document to be searched
     * @param  fragRoot  The fragment (from oldDoc) to be sought
     */
    public void doMatch(Document newDoc, Node fragRoot) {
        // Clear the cache
        cache = new Hashtable();
    }


    /**
     *  Gets the next closest match, must be called after a doMatch()
     *
     * @return    The next closest match
     */
    public Match getNextMatch() {
        return null;
    }


    /**
     *  Description of the Method
     *
     * @param  a  Description of the Parameter
     * @param  b  Description of the Parameter
     * @return    Description of the Return Value
     */
    protected HashSet seenBefore;

    int maxDepth = 0;


    /**
     *  Description of the Method
     *
     * @param  a      Description of the Parameter
     * @param  b      Description of the Parameter
     * @param  depth  Description of the Parameter
     * @param  wt     Description of the Parameter
     * @return        Description of the Return Value
     */

    public float compare(Node a, Node b, int depth, WeightTracker wt) {
        maxDepth = depth;
        seenBefore = new HashSet();
        return (float) bfCompare(a, b, depth);
    }


    /**
     *  Description of the Method
     *
     * @param  a      Description of the Parameter
     * @param  b      Description of the Parameter
     * @param  depth  Description of the Parameter
     * @return        Description of the Return Value
     */
    public float compare(Node a, Node b, int depth) {
        maxDepth = depth;
        seenBefore = new HashSet();
        return (float) bfCompare(a, b, depth);
    }


    double bfCompare(Node ia, Node ib, int maxNodes) {
        //, WeightTracker wt) {
        LinkedList q = new LinkedList();
        q.add(new WeightedPair(ia, ib, 1));

        int nodesVisited = 0;
        double maxValue = 0.0;
        double totalValue = 0.0;

        while (!q.isEmpty() && nodesVisited < maxNodes) {
            WeightedPair p = (WeightedPair) q.removeFirst();
            Node a = p.a;
            Node b = p.b;
            float weight = p.weight;

            nodesVisited++;

            // Prevent loops
            if (seenBefore.contains(a)) {
                continue;
            }
            seenBefore.add(a);

            float closeness = compareNodes(a, b, null);
            totalValue += (closeness * weight);
            maxValue += weight;

            // Attribute recurse
            NamedNodeMap nnma = a.getAttributes();
            NamedNodeMap nnmb = b.getAttributes();
            int act = 0;
            if ((nnma != null) && (nnmb != null)) {
                for (int x = 0; x < Math.min(nnma.getLength(), nnmb.getLength()); x++) {
                    q.addLast(new WeightedPair(nnma.item(x), nnmb.item(x),
                            (attributeWeight * weight) /
                            Math.min(nnma.getLength(), nnmb.getLength())));
                }
            }

            // Parent recurse
            if (a.getParentNode() != null && b.getParentNode() != null) {
                q.addLast(new WeightedPair(a.getParentNode(), b.getParentNode(), parentWeight * weight));
            }

            //Children recurse
            NodeList nla = a.getChildNodes();
            NodeList nlb = b.getChildNodes();
            if ((nla != null) && (nlb != null)) {
                if (Math.max(nla.getLength(), nlb.getLength()) != 0) {
                    for (int x = 0; x < Math.min(nla.getLength(), nlb.getLength()); x++) {
                        q.addLast(new WeightedPair(nla.item(x), nlb.item(x),
                                (childrenWeight * weight) / Math.min(nla.getLength(), nlb.getLength())));
                    }
                }
            }
        }
        return totalValue / maxValue;
    }


    /**
     *  Compares two nodes and determines their degree of similarity
     *
     * @param  a   The first node to be compared
     * @param  b   The second node to be compared
     * @param  wt  Description of the Parameter
     * @return     The degree of similarity, 0=totally dissimilar 1=virtually identical
     */
    public float compareNodes(Node a, Node b, WeightTracker wt) {

        float ret = 0;
        /*
         *  Comment out as this would screw up WeightTracker
         *  / If closeness has been cached, then return immediately
         *  Float f = (Float) cache.get(new Integer(a.hashCode() ^ b.hashCode()));
         *  if (f != null) {
         *  return f.floatValue();
         *  }
         */
        float nodePosScore = 0;
        // Determine relative positions of each node within parent tree
        if ((a.getParentNode() != null) && (b.getParentNode() != null)) {
            int apos = 0;
            int bpos = 0;
            Node pp = a;
            while (pp != null) {
                pp = pp.getPreviousSibling();
                apos++;
            }
            pp = b;
            while (pp != null) {
                pp = pp.getPreviousSibling();
                bpos++;
            }
            if (apos != bpos) {
                nodePosScore = 1F / ((float) (Math.abs(apos - bpos)));
            } else {
                nodePosScore = 1F;
            }
        } else if ((a.getParentNode() == null) && (b.getParentNode() == null)) {
            nodePosScore = 1F;
        }
        ret += nodeSiblingPosWeight * nodePosScore;
        if (wt != null) {
            wt.nodeSiblingPos += nodeSiblingPosWeight * nodePosScore;
        }
        if (a.getNodeName().toLowerCase().equals(b.getNodeName().toLowerCase())) {
            ret += nodeNameWeight;
            if (wt != null) {
                wt.nodeName += nodeNameWeight;
            }
        }
        ret += attributeNumberWeight * compAttributeNo(a, b);
        if (wt != null) {
            wt.attributeNumber += attributeNumberWeight * compAttributeNo(a, b);
        }
        ret += childNumberWeight * compChildNo(a, b);
        if (wt != null) {
            wt.childNumber += childNumberWeight * compChildNo(a, b);
        }
        float sd = StringDist.dist(a.getNodeValue(), b.getNodeValue());
        ret += nodeValueWeight * sd;
        if (wt != null) {
            wt.nodeValue += nodeValueWeight * sd;
        }
        // Cache this
        cache.put(new Integer(a.hashCode() ^ b.hashCode()), new Float(ret));

        if (DEBUG) {
            System.err.println(":::::::::::::::::: compareNodes(" + a.getNodeName() + ", " + b.getNodeName() +
                    ") -> " + ret);
        }
        return ret;
    }


    /**
     *  Description of the Method
     *
     * @param  a  Description of the Parameter
     * @param  b  Description of the Parameter
     * @return    Description of the Return Value
     */
    protected float compAttributeNo(Node a, Node b) {
        // Attribute number comparison
        int la;
        int lb;
        NamedNodeMap nnma = a.getAttributes();
        NamedNodeMap nnmb = b.getAttributes();
        if (nnma != null) {
            la = nnma.getLength();
        } else {
            la = 0;
        }
        if (nnmb != null) {
            lb = nnmb.getLength();
        } else {
            lb = 0;
        }

        return (float) (1 / Math.pow(2, (Math.abs(la - lb))));
    }


    /**
     *  Description of the Method
     *
     * @param  a  Description of the Parameter
     * @param  b  Description of the Parameter
     * @return    Description of the Return Value
     */
    protected float compChildNo(Node a, Node b) {
        // Attribute number comparison
        int la;
        int lb;
        NodeList nnma = a.getChildNodes();
        NodeList nnmb = b.getChildNodes();
        if (nnma != null) {
            la = nnma.getLength();
        } else {
            la = 0;
        }
        if (nnmb != null) {
            lb = nnmb.getLength();
        } else {
            lb = 0;
        }
        return (float) (1 / Math.pow(2, (Math.abs(la - lb))));
    }


    /**
     *  Description of the Class
     *
     * @author     ian
     * @created    September 18, 2002
     */
    public class Match {
        /**  Description of the Field */
        public Node n;
        /**  Description of the Field */
        public float closeness;
    }


    /**
     *  Description of the Class
     *
     * @author     ian
     * @created    September 21, 2002
     */
    public class WeightTracker {
        /**  Description of the Field */
        public float nodeName = 0, nodeValue = 0, attributeNumber = 0, childNumber = 0,
                children = 0, attribute = 0, parent = 0, local = 0, nodeSiblingPos = 0;


        /**Constructor for the WeightTracker object */
        public WeightTracker() { }


        /**
         *  Description of the Method
         *
         * @return    Description of the Return Value
         */
        public String toString() {
            return "nodeName:" + nodeName + ", nodeValue: " + nodeValue + ", attrNo: " + attributeNumber +
                    ", childNo: " + childNumber + ", chldrn: " + children + ", attr: " + attribute +
                    ", parent: " + parent + ", local: " + local + ", nodeSiblingPos: " + nodeSiblingPos;
        }


        /**
         *  Description of the Method
         *
         * @return    Description of the Return Value
         */
        public float total() {
            return nodeName + nodeValue + attributeNumber + childNumber +
                    children + attribute + parent + local;
        }


        /**Constructor for the reset object */
        public void reset() {
            nodeName = 0;
            nodeValue = 0;
            attributeNumber = 0;
            childNumber = 0;
            children = 0;
            attribute = 0;
            parent = 0;
            local = 0;
            nodeSiblingPos = 0;
        }
    }
}

