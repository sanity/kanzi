package msmd;

import org.w3c.dom.*;
import java.util.Stack;
import java.util.HashMap;

/**
 *  Description of the Class
 *
 * @author     ian
 * @created    September 25, 2002
 */
public class TreeIndex {

  protected static final int INDEX=0, 
      CHILDCOUNT=1, DEPTH=2;
  protected static final Object DEPTHMARKER=new Object();
  
  /**  Description of the Field */
  protected HashMap index;

  /**
   * Indexes the tree rooted at the given parameter
   *
   * @param  rootNode  Description of the Parameter
   */
  public TreeIndex(Node rootNode) {
    index = new HashMap();
    index(rootNode, 0);
  }


  /**
   *  Gets the indexVal attribute of the TreeIndex object
   *
   * @param  n  Description of the Parameter
   * @return    The indexVal value
   */
  public int getIndexVal(Node n) {
    int[] i = (int[]) index.get(n);
    if (i == null) {
      return -1;
    } else {
      return i[INDEX];
    }
  }

  /**
   *  Gets the depth attribute of the TreeIndex object (the
   * depth below the given node)
   *
   * @param  n  Description of the Parameter
   * @return    The indexVal value
   */
  public int getDepth(Node n) {
    int[] i = (int[]) index.get(n);
    if (i == null) {
      return -1;
    } else {
      return i[DEPTH];
    }
  }

  /**
   *  Gets the child count attribute of the TreeIndex object (the
   *  numbers of nodes below the given node)
   *
   * @param  n  Description of the Parameter
   * @return    The childCount value
   */
  public int getChildCount(Node n) {
    int[] i = (int[]) index.get(n);
    if (i == null) {
      return -1;
    } else {
      return i[CHILDCOUNT];
    }
  }


  /**
   *  Gets the node attribute of the TreeIndex object
   *
   * @param  indexVal  Description of the Parameter
   * @return           The node value
   */
  public Node getNode(int indexVal) {
    return (Node)index.get(new Integer(indexVal));
  }


  /**
   *  Description of the Method
   *
   * @param  s  Description of the Parameter
   */
   int index(Node n, int d) {
       int childCount=0;
       if (n.hasChildNodes()) {
           NodeList nm = n.getChildNodes();
           for (int i = 0; i < nm.getLength(); i++) {
               childCount+=index(nm.item(i), d+1);
           }
       }        

       int iv=hashNode(n);
       int[] v=new int[3];
       v[INDEX]=iv;
       v[CHILDCOUNT]=childCount;
       v[DEPTH]=d;
       index.put(n, v);
       index.put(new Integer(iv), n);
       return childCount+1;
   }

  /**
   *  Description of the Method
   *
   * @param  n  Description of the Parameter
   * @return    Description of the Return Value
   */
  int hashNode(Node n) {
    int v = hashNodeDetails(n);
    if (n.hasChildNodes()) {
      NodeList nm = n.getChildNodes();
      for (int i = 0; i < nm.getLength(); i++) {
          v = ((v << 3) | (v >>> 29)) ^ getIndexVal(nm.item(i));
      }
    }
    return v;
  }


  /**
   *  Description of the Method
   *
   * @param  n  Description of the Parameter
   * @return    Description of the Return Value
   */
  static int hashNodeDetails(Node n) {
    int v = n.getNodeName().hashCode() ^ n.getNodeValue().hashCode() ^
        ((int) n.getNodeType() << 16);

    NamedNodeMap nm = n.getAttributes();
    if (nm != null) {
      for (int i = 0; i < nm.getLength(); i++) {
        v ^= hashNodeDetails(nm.item(i));
      }
    }
    return v;
  }


  /**
   *  The main program for the TreeIndex class
   *
   * @param  args           The command line arguments
   * @exception  Exception  Description of the Exception
   */
  public static void main(String[] args) throws Exception {
    Document d = HTMLReader.readPage(args[0]);
    TreeIndex i = new TreeIndex(d);
    Node a = msmd.tests.BestMatch.findHTML(d);
    System.err.println(i.getIndexVal(a));
    d = HTMLReader.readPage(args[0]);
    i = new TreeIndex(d);
    Node b = msmd.tests.BestMatch.findHTML(d);
    System.err.println(i.getIndexVal(b));
  }

}

